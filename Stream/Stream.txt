				##Stream 总览
###什么是流
Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。

Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。

而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：

    1.0-1.4 中的 java.lang.Thread
    5.0 中的 java.util.concurrent
    6.0 中的 Phasers 等
    7.0 中的 Fork/Join 框架
    8.0 中的 Lambda
Stream 的另外一大特点是，数据源本身可以是无限的。

###流的构成
当我们使用一个流的时候，通常包括三个基本步骤：

获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。

结束语

总之，Stream 的特性可以归纳为：

    不是数据结构
    它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。
    它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。
    所有 Stream 的操作必须以 lambda 表达式为参数
    不支持索引访问
    你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。
    很容易生成数组或者 List
    惰性化
    很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。
    Intermediate 操作永远是惰性化的。
    并行能力
    当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。
    可以是无限的
    集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。


    流的操作是内部迭代的，之前使用诸如for循环、迭代器属于外部迭代。不过在java8中内部迭代的性能还是略差一些，相信在后面的版本中会有所提升。注意：流只能使用一次，使用结束之后，这个流也就废掉了。


map和reduce

    map用来归类，结果一般是一组数据，比如可以将list中的学生分数映射到一个新的stream中。
    reduce用来计算值，结果是一个值，比如计算最高分。






