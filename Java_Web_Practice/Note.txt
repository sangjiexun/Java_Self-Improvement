day01_基础加强
1. 什么是黑盒和白盒测试？
黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
白盒测试：需要写代码的。关注程序具体的执行流程。
2. Assert.assertEquals(期望的结果,运算的结果);
进行单元测试时，一定先要引入Junit包才可以使用。并且该注解必须在方法名上。
3.  @Before:
                * 修饰的方法会在测试方法之前被自动执行
            * @After:
                * 修饰的方法会在测试方法执行之后自动被执行
4. 一个单元测试用例执行顺序为：@BeforeClass（必须是static void） –> @Before –> @Test –> @After –> @AfterClass （必须是static void）


/**
     * 初始化方法：
     *  用于资源申请，所有测试方法在执行之前都会先执行该方法
     */
    @Before
    public void init(){
        System.out.println("init...");
    }

    /**
     * 释放资源方法：
     *  在所有测试方法执行完后，都会自动执行该方法
     */
    @After
    public void close(){
        System.out.println("close...");
}
5.反射：将类的各个组成部分封装为其他对象，这就是反射机制
* 好处：
            1. 可以在程序运行过程中，操作这些对象。
            2. 可以解耦，提高程序的可扩展性。
6. JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
7. 获取Class对象的方式：
        1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
            * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
        2. 类名.class：通过类名的属性class获取
            * 多用于参数的传递

        3. 对象.getClass()：getClass()方法在Object类中定义着。（一般用第三种）
            * 多用于对象的获取字节码的方式
8.反射对象功能概述
	获取功能
		1. 获取成员变量们
				* Field[] getFields() ：获取所有public修饰的成员变量
				* Field getField(String name)   获取指定名称的 public修饰的成员变量
				* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
				* Field getDeclaredField(String name)  
			2. 获取构造方法们
				* Constructor<?>[] getConstructors()  
				* Constructor<T> getConstructor(类<?>... parameterTypes)  

				* Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  
				* Constructor<?>[] getDeclaredConstructors()  
			3. 获取成员方法们：
				* Method[] getMethods()  
				* Method getMethod(String name, 类<?>... parameterTypes)  
* Method[] getDeclaredMethods()  
				* Method getDeclaredMethod(String name, 类<?>... parameterTypes)  
			4. 获取全类名	
				* String getName()  

	通过class字节码对象可以获取该类的方法以及属性
9. Class对象获取Field
	Class personClass=Person.class;
        Field[]  fields=personClass.getFields();
        for (Field field : fields) {//iter
            System.out.println("getFileds(): "+field);
        }

        Field field=personClass.getField("a");
        System.out.println("getField(): "+field);
        System.out.println("=====================================================");


        Field a=personClass.getField("a");
        Person p=new Person();
        Object value=a.get(p);
        System.out.println(p);
        a.set(p,1);
        System.out.println(p);


        System.out.println("=====================================================");

        Field[] fiels2=personClass.getDeclaredFields();
        for (Field field2 : fiels2) {
            System.out.println("getDeclaredFields(): "+field2);
        }

        Field field3=personClass.getDeclaredField("name");
        System.out.println("getDeclaredField(): "+field3);
10. Class对象功能_获取Constructor
构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。
如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance
Class personClass=Person.class;
        Constructor constructor=personClass.getConstructor();
        Object p1=constructor.newInstance();
        System.out.println(p1);
        System.out.println("=========================================");


        Constructor constructor1=personClass.getConstructor(String.class,String.class);
        Object person1=constructor1.newInstance("aaa","bbb");
        System.out.println(person1);
        System.out.println("=========================================");

        Object person=personClass.newInstance();
        System.out.println(person);
11. class对象获取Method
使用method.getParameterTypes();可以获取该方法的参数
Class personClass=Person.class;
        Method[] methods=personClass.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
        System.out.println("=============================");

        Method method01=personClass.getMethod("eat");
        Person person=new Person();
        method01.invoke(person);
        System.out.println("==============================");
        Method method02=personClass.getMethod("eat",String.class);
        method02.invoke(person,"zhangsan")
12.反射
首先要从配置文件中读取该类的全限定类名，然后用class.forName()，来获取该类的class对象，再通过class对象获取并执行成员方法。
Properties properties=new Properties();
        ClassLoader cl=ClassTest05.class.getClassLoader();
        InputStream is=cl.getResourceAsStream("source.properties");
        properties.load(is);

        String className=properties.getProperty("className");
        String method=properties.getProperty("methodName");
        Class personClass=Class.forName(className);
        Object person=personClass.newInstance();
        Method method1=personClass.getMethod("eat");
        method1.invoke(person);
13* 作用分类：
		①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
		②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
		③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】
	
注解就是为了简化开发，避免写过多的代码，不利于程序的扩展以及维护        * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的
        * @Deprecated：该注解标注的内容，表示已过时
        * @SuppressWarnings：压制警告
            * 一般传递参数all  @SuppressWarnings("all")
14. 编写代码实现自定义注解
public @interface MyAnno {

     int value();
    Person per();
    MyAnno2 anno2();
    String[] strs();
     /*String name() default "张三";*/
     /*String show2();

     Person per();
     MyAnno2 anno2();

     String[] strs();*/


}
15. 元注解：用于描述注解的注解
            * @Target：描述注解能够作用的位置
                * ElementType取值：
                    * TYPE：可以作用于类上
                    * METHOD：可以作用于方法上
                    * FIELD：可以作用于成员变量上
            * @Retention：描述注解被保留的阶段
                * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
            * @Documented：描述注解是否被抽取到api文档中
            * @Inherited：描述注解是否被子类继承

day02__mysql基础
1.MySQL登录
            	1. mysql -uroot -p密码
          	 2. mysql -hip -uroot -p连接目标的密码
           	 3. mysql --host=ip --user=root --password=连接目标的密码
         MySQL退出
            	1. exit
            	2. quit
2.structured Query Language：结构化查询语言
其实就是定义了操作所有关系型数据库的规则
3.       . 3 种注释
            * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
            * 多行注释: /* 注释 */
4.SQL分类
1) DDL(Data Definition Language)数据定义语言
            用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
        2) DML(Data Manipulation Language)数据操作语言
            用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
        3) DQL(Data Query Language)数据查询语言
            用来查询数据库中表的记录(数据)。关键字：select, where 等
        4) DCL(Data Control Language)数据控制语言(了解)
            用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等


5.操作数据库：CRUD
		1. C(Create):创建
			* 创建数据库：
				* create database 数据库名称;
			* 创建数据库，判断不存在，再创建：
				* create database if not exists 数据库名称;
			* 创建数据库，并指定字符集
				* create database 数据库名称 character set 字符集名;

			* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
				* create database if not exists db4 character set gbk;
		2. R(Retrieve)：查询
			* 查询所有数据库的名称:
				* show databases;
			* 查询某个数据库的字符集:查询某个数据库的创建语句
				* show create database 数据库名称;
            3.U(Update):修改
			* 修改数据库的字符集
				* alter database 数据库名称 character set 字符集名称;
		4.D(Delete):删除
			* 删除数据库
				* drop database 数据库名称;
			* 判断数据库存在，存在再删除
				* drop database if exists 数据库名称;


6.使用数据库
			* 查询当前正在使用的数据库名称
				* select database();//不要忘记写()
			* 使用数据库
				* use 数据库名称;


7.查询某个数据库中所有的表名称
                * show tables;
            * 查询表结构(看表的键和值等)
                * desc 表名;

8.C(Create):创建
            1. 语法：
                create table 表名(
                    列名1 数据类型1,
                    列名2 数据类型2,
                    ....
                    列名n 数据类型n
                );
                * 注意：最后一列，不需要加逗号（,）

9.drop table 表名;
            * drop table  if exists 表名 ;

10.
1. 修改表名
				alter table 表名 rename to 新的表名;
			2. 修改表的字符集
				alter table 表名 character set 字符集名称;
			3. 添加一列
				alter table 表名 add 列名 数据类型;
			4. 修改列名称 类型
				alter table 表名 change 列名 新列别 新数据类型;
				alter table 表名 modify 列名 新数据类型;
			5. 删除列
				alter table 表名 drop 列名;
				
11.DML添加数据
* 语法：
            * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
        * 注意：
            1. 列名和值要一一对应。
            2. 如果表名后，不定义列名，则默认给所有列添加值
                insert into 表名 values(值1,值2,...值n);
            3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
12.DML删除数据
* 语法：
            * delete from 表名 [where 条件]
        * 注意：
            1. 如果不加条件，则删除表中所有记录。
            2. 如果要删除所有记录
                1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
                2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
13.DML修改数据
修改数据：
		* 语法：
			* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

		* 注意：
			1. 如果不加任何条件，则会将表中所有记录全部修改。


14.DQL基础查询

		1.多个字段的查询
			select 字段名1，字段名2... from 表名；
			* 注意：
			* 如果查询所有字段，则可以使用*来替代字段列表。
		2.去除重复：
			* distinct
		3.计算列
			* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
			* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
			* 表达式1：哪个字段需要判断是否为null
			* 如果该字段为null后的替换值。
		4.起别名：
			* as：as也可以省略

15.DQL条件查询
1. where子句后跟条件
		2. 运算符
			* > 、< 、<= 、>= 、= 、<>
			* BETWEEN...AND  
			* IN( 集合) 
			* LIKE：模糊查询
				* 占位符：
					* _:单个任意字符
					* %：多个任意字符
			* IS NULL  
			* and  或 &&
			* or  或 || 
			* not  或 !
16.DQL条件查询_模糊查询
LIKE：模糊查询
                * 占位符：
                    * _:单个任意字符
                    * %：多个任意字符
全国有多少人的名字中有“伟”的，就要用到like ‘%伟%’
17.DQL排序查询
语法：order by 子句
            * order by 排序字段1 排序方式1 ，排序字段2 排序方式2...
        * 排序方式：
            * ASC：升序，默认的。
            * DESC：降序
注意：
            * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件
18.DQL聚合函数
聚合函数对一组值执行计算并返回单一的值。除了 COUNT 以外，聚合函数忽略空值。聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。
聚合函数：将一列数据作为一个整体，进行纵向的计算。
        1. count：计算个数
            1. 一般选择非空的列：主键
 	    2. count(*)
        2. max：计算最大值
        3. min：计算最小值
        4. sum：计算和
        5. avg：计算平均值
19.DQL分组查询
	GROUP BY关键字可以将查询结果按照某个字段或多个字段进行分组。字段中值相等的为一组。基本的语法格式如下：
GROUP BY 属性名 [HAVING 条件表达式] [WITH ROLLUP]
   	• 属性名：是指按照该字段的值进行分组。
    	• HAVING 条件表达式：用来限制分组后的显示，符合条件表达式的结果将被显示。
    	• WITH ROLLUP：将会在所有记录的最后加上一条记录。加上的这一条记录是上面所有记录的总和。

	1. 语法：group by 分组字段；
        2. 注意：
            1. 分组之后查询的字段：分组字段、聚合函数
            2. where 和 having 的区别？
                1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
                2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。


ROUP BY关键字可以和GROUP_CONCAT()函数一起使用。GROUP_CONCAT()函数会把每个分组中指定的字段值都显示出来。

同时，GROUP BY关键字通常与集合函数一起使用。集合函数包括COUNT()函数、SUM()函数、AVG()函数、MAX()函数和MIN()函数等。

sql语句的执行过程是：from-->where-->group by -->having --- >order by --> select;
其执行顺序为：FROM-WHERE-GROUP BY-HAVING-SELECT-DISTINCT-UNION-ORDER BY
Mysql执行顺序：开始->FROM子句->WHERE子句->GROUP BY子句->HAVING子句->ORDER BY子句->SELECT子句->LIMIT子句->最终结果
聚合函数是针对结果集进行的，但是where条件并不是在查询出结果集之后运行，所以主函数放在where语句中，会出现错误，

而having不一样，having是针对结果集做筛选的，所以我门一般吧组函数放在having中，用having来代替where，having一般跟在group by后

20.约束概述 
对表中的数据进行限定，保证数据的正确性、有效性和完整性。
	主键约束（Primary Key constraint）：要求主键列数据唯一，并且不允许为空。
	唯一约束（Unique constraint）：要求该列唯一，允许为空，但只能出现一个空值。
	检查约束（Check constraint）：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。
	默认约束（Default constraint）：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。
	外键约束（Foreign Key constraint）：用于在两个表之间建立关系，需要指定引用主表的哪一列。

21.约束_非空约束
not null，某一列的值不能为null
	1. 创建表时添加约束
            CREATE TABLE stu(
                id INT,
                NAME VARCHAR(20) NOT NULL -- name为非空
            );
 	2. 创建表完后，添加非空约束
            ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;
 	3. 删除name的非空约束
            ALTER TABLE stu MODIFY NAME VARCHAR(20);

22. 约束_唯一约束
unique，某一列的值不能重复。注意：null值可以有多个。
唯一约束：unique，某一列的值不能重复
        1. 注意：
            * 唯一约束可以有NULL值
        2. 在创建表时，添加唯一约束
            CREATE TABLE stu(
                id INT,
                phone_number VARCHAR(20) UNIQUE -- 手机号
            );
        3. 删除唯一约束
            ALTER TABLE stu DROP INDEX phone_number;
        4. 在表创建完后，添加唯一约束
            ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
23.约束_主键约束
	primary key，非空并且唯一，一张表只能有一个主键，主键是表的唯一标识
	主键约束：primary key。
        1. 注意：
            1. 含义：非空且唯一
            2. 一张表只能有一个字段为主键
            3. 主键就是表中记录的唯一标识

        2. 在创建表时，添加主键约束
            create table stu(
                id int primary key,-- 给id添加主键约束
                name varchar(20)
            );

        3. 删除主键
            -- 错误 alter table stu modify id int ;
            ALTER TABLE stu DROP PRIMARY KEY;

        4. 创建完表后，添加主键
            ALTER TABLE stu MODIFY id INT PRIMARY KEY;



	主键主要用在查询单调数据，修改单调数据和删除单调数据上。
24.约束_主键约束_自动增长
	自动增长：
            1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完	成值得自动增长

            2. 在创建表时，添加主键约束，并且完成主键自增长
            create table stu(
                id int primary key auto_increment,-- 给id添加主键约束
                name varchar(20)
            );

            
            3. 删除自动增长
            ALTER TABLE stu MODIFY id INT;
            4. 添加自动增长
            ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;


	优点是：
		1.自动编号 速度快
		2.数字型 占用空间小 易排序
		3.不用担心主键重复的问题
	缺点是:
		1.在异库异构的数据库的情况下 容易新老主键混合 会发生冲突
		2.在系统集成的时候 如果主键的类型不一样的话 会导致其他外建关联的表的修改
		3.若系统也是数字型的，在导入时，为了区分新老数据，可能想在老数据主键前统一加一个字符标识（例如“o”，old）来表示这是老数据，那么自动增长的数字型又面临一个挑战。

25.约束_外键约束
foreign key,让表于表产生关系，从而保证数据的正确性。
外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。
        1. 在创建表时，可以添加外键
            * 语法：
                create table 表名(
                    ....
                    外键列
                    constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
                );

        2. 删除外键
            ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;

        3. 创建表之后，添加外键
            ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);

26.约束_外键约束_级联操作
	A表与B表有外键约束，A中有外键，B中数据改变时，A中的外键字段对应做出改变。
		1. 添加级联操作
                语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
                        FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;
           	2. 分类：
                1. 级联更新：ON UPDATE CASCADE 
                2. 级联删除：ON DELETE CASCADE 
27.多表关系介绍
		1.一对一(了解)：
                * 如：人和身份证
                * 分析：一个人只有一个身份证，一个身份证只能对应一个人
           	2. 一对多(多对一)：
                * 如：部门和员工
                * 分析：一个部门有多个员工，一个员工只能对应一个部门
            	3. 多对多：
		* 如：学生和课程
                * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
		 多对多：
                * 如：学生和课程
                * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键

		需要创建一张中间表来维护两张主表之间的关系，并且中间表最少要有两个字段。
		
28.三大范式详解
1. 第一范式（1NF）：每一列都是不可分割的原子数据项
2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）
       * 几个概念：
          1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
            例如：学号-->姓名。  （学号，课程名称） --> 分数
          2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
            例如：（学号，课程名称） --> 分数
          3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
            例如：（学号，课程名称） -- > 姓名
          4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
            例如：学号-->系名，系名-->系主任
          5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
             例如：该表中码为：（学号，课程名称）
                   * 主属性：码属性组中的所有属性
                   * 非主属性：除过码属性组的属性                 
3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

29.数据库范式的作用？
是为了在设计中更好的解决数据冗余，数据有效性检查，提高存储效率考虑。

30.数据库的备份和还原

31.多表查询_概述
一次查询多张数据库表.

分类：内连接查询，外链接查询，子查询
	
多表查询语法
	查询语法：
        select
            列名列表
        from
            表名列表
        where....

32.多表查询_内连接

内连接是从结果表中删除与其他被连接表中没有匹配行的所有行，所以内连接可能会丢失信息。

* 笛卡尔积：
      * 有两个集合A,B .取这两个集合的所有组成情况。
      * 要完成多表查询，需要消除无用的数据

显式内连接：
       * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
       * 例如：
           * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;    
           * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;    


内连接查询：
         1. 从哪些表中查询数据
         2. 条件是什么
         3. 查询哪些字段

1.1.等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。
1.2.不等值连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括>、>=、<=、<、!>、!<和<>。
1.3.自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。

区别：自然连接要求两个关系中相等的分量必须是相同属性组，而等值连接不必，自然连接要在结果中把重复的属性去掉
联系：自然连接是一种特殊的等值连接

1. 等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。如上例R中的C列和S中的D列可进行等值连接，但因为属性名不同，不能进行自然连接。 

 

  2. 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。如上例R中的B列和S中的B列进行等值连接时，结果有两个重复的属性列B,而进行自然连接时，结果只有一个属性列B。 


33.多表查询_外连接
外连接分为：左外连接，右外连接
在左外连接和右外连接时都会以一张表为基表，该表的内容会全部显示，然后加上两张表匹配的内容。如果基表的数据在另一张表没有记录。那么在相关联的结果集行中列显示为空值（NULL）。
1. 左外连接：
         * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
         * 查询的是左表所有数据以及其交集部分。
         * 例子：
              -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
              SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
2. 右外连接：
          * 语法：
		select 字段列表 from 表1 right [outer] join 表2 on 条件；
          * 查询的是右表所有数据以及其交集部分。
          * 例子：
                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;



总结与补充
1）LEFT  JOIN或LEFT OUTER JOIN     
左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。       
2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN     
右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。   

34.查询中嵌套查询，称嵌套查询为子查询
	在SQL语言中，一个SELECT-FROM-WHERE语句称为一个查询块。当获得一个查询的答案需要多个步骤的操作，首先必须创建一个查询来确定用户不知道但包含在数据库中的值，将一个查询块嵌套在另一个查询块的WHERE字句或HAVING短语的条件中查询块称为子查询或内层查询。

35.
1.子查询的结果是单行单列的：
             * 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =
             * 
                -- 查询员工工资小于平均工资的人
          SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp); 
2.子查询的结果是多行单列的：
             * 子查询可以作为条件，使用运算符in来判断
                    -- 查询'财务部'和'市场部'所有的员工信息
              SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';
              SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
                    -- 子查询
              SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');

3.子查询的结果是多行多列的：
              * 子查询可以作为一张虚拟表参与查询
               -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
               -- 子查询
                 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2 WHERE t1.id = t2.dept_id;
36.事务基本演示
1.如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。
2.一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。
3.银行转账的例子

37.事务_默认自动提交&手动提交
	事务提交的两种方式：
                * 自动提交：
                    * mysql就是自动提交的
                    * 一条DML(增删改)语句会自动提交一次事务。
                * 手动提交：
                    * Oracle 数据库默认是手动提交事务
                    * 需要先开启事务，再提交
            * 修改事务的默认提交方式：
                * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
                * 修改默认提交方式： set @@autocommit = 0;

事务有两种提交方式：自动提交与手动提交
	手动提交需要开启事务START TRANSACTION; ，操作完成后，还必须提交事务COMMIT;，修改后的数据才会生效。

38.事务_事务的四大特征
	1. 原子性(Atomicity)：是不可分割的最小操作单位，要么同时成功，要么同时失败。
        2. 一致性(Consistency)：事务操作前后，数据总量不变
        3. 隔离性(Isolation)：多个事务之间。相互独立。
        4. 持久性(Durability)：当事务提交或回滚后，数据库会持久化的保存数据。

39.事务_事务的隔离级别介绍
		* 存在问题：
			1. 脏读：一个事务，读取到另一个事务中没有提交的数据
			2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
			3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
		* 隔离级别：
			1. read uncommitted：读未提交
				* 产生的问题：脏读、不可重复读、幻读
			2. read committed：读已提交 （Oracle）
				* 产生的问题：不可重复读、幻读
			3. repeatable read：可重复读 （MySQL默认）
				* 产生的问题：幻读
			4. serializable：串行化
				* 可以解决所有的问题

			* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
			* 数据库查询隔离级别：
				* select @@tx_isolation;
			* 数据库设置隔离级别：
				* set global transaction isolation level  级别字符串;

40.事务_事务隔离级别演示
	修改事务的隔离级别： 
	set global transaction isolation level 级别字符串;
	练习时一定要重连mysql并且先开启事务：
		start transaction;
	操作完成后需手动提交事务：
		Commit；

只有重新连接mysql后，隔离级别才可以生效

41.DCL_管理用户_增删查
  * DCL：管理用户，授权
        1. 管理用户
            1. 添加用户：
                * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
            2. 删除用户：
                * 语法：DROP USER '用户名'@'主机名';
            3. 修改用户密码：
                
                UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';
                UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi';
                
                SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');
                SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123');

                * mysql中忘记了root用户的密码？
                    1. cmd -- > net stop mysql 停止mysql服务
                        * 需要管理员运行该cmd

                    2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                    3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                    4. use mysql;
                    5. update user set password = password('你的新密码') where user = 'root';
                    6. 关闭两个窗口
                    7. 打开任务管理器，手动结束mysqld.exe 的进程
                    8. 启动mysql服务
                    9. 使用新密码登录。
            4. 查询用户：
                -- 1. 切换到mysql数据库
                USE myql;
                -- 2. 查询user表
                SELECT * FROM USER;
	* 通配符： % 表示可以在任意主机使用用户登录数据库
添加用户的时候要设置用户的ip地址，可以有效防止密码被盗取后，其他人访问数据库，对数据库造成损坏，极大提高数据库的安全性

42.DCL_管理权限
	    1. 查询权限：
                -- 查询权限
                SHOW GRANTS FOR '用户名'@'主机名';
                SHOW GRANTS FOR 'lisi'@'%';

            2. 授予权限：
                -- 授予权限
                grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
                -- 给张三用户授予所有权限，在任意数据库任意表上
                
                GRANT ALL ON *.* TO 'zhangsan'@'localhost';
            3. 撤销权限：
                -- 撤销权限：
                revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';
                REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';


	权限管理极大提高了数据库的安全性，有效降低了数据库数据被误删的几率。
	授权的关键字为:   grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
	撤销权限的关键字为：revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';

43.









