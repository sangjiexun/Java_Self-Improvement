day01_基础加强
1. 什么是黑盒和白盒测试？
黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
白盒测试：需要写代码的。关注程序具体的执行流程。
2. Assert.assertEquals(期望的结果,运算的结果);
进行单元测试时，一定先要引入Junit包才可以使用。并且该注解必须在方法名上。
3.  @Before:
                * 修饰的方法会在测试方法之前被自动执行
            * @After:
                * 修饰的方法会在测试方法执行之后自动被执行
4. 一个单元测试用例执行顺序为：@BeforeClass（必须是static void） –> @Before –> @Test –> @After –> @AfterClass （必须是static void）


/**
     * 初始化方法：
     *  用于资源申请，所有测试方法在执行之前都会先执行该方法
     */
    @Before
    public void init(){
        System.out.println("init...");
    }

    /**
     * 释放资源方法：
     *  在所有测试方法执行完后，都会自动执行该方法
     */
    @After
    public void close(){
        System.out.println("close...");
}
5.反射：将类的各个组成部分封装为其他对象，这就是反射机制
* 好处：
            1. 可以在程序运行过程中，操作这些对象。
            2. 可以解耦，提高程序的可扩展性。
6. JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
7. 获取Class对象的方式：
        1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
            * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
        2. 类名.class：通过类名的属性class获取
            * 多用于参数的传递

        3. 对象.getClass()：getClass()方法在Object类中定义着。（一般用第三种）
            * 多用于对象的获取字节码的方式
8.反射对象功能概述
	获取功能
		1. 获取成员变量们
				* Field[] getFields() ：获取所有public修饰的成员变量
				* Field getField(String name)   获取指定名称的 public修饰的成员变量
				* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
				* Field getDeclaredField(String name)  
			2. 获取构造方法们
				* Constructor<?>[] getConstructors()  
				* Constructor<T> getConstructor(类<?>... parameterTypes)  

				* Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  
				* Constructor<?>[] getDeclaredConstructors()  
			3. 获取成员方法们：
				* Method[] getMethods()  
				* Method getMethod(String name, 类<?>... parameterTypes)  
* Method[] getDeclaredMethods()  
				* Method getDeclaredMethod(String name, 类<?>... parameterTypes)  
			4. 获取全类名	
				* String getName()  

	通过class字节码对象可以获取该类的方法以及属性
9. Class对象获取Field
	Class personClass=Person.class;
        Field[]  fields=personClass.getFields();
        for (Field field : fields) {//iter
            System.out.println("getFileds(): "+field);
        }

        Field field=personClass.getField("a");
        System.out.println("getField(): "+field);
        System.out.println("=====================================================");


        Field a=personClass.getField("a");
        Person p=new Person();
        Object value=a.get(p);
        System.out.println(p);
        a.set(p,1);
        System.out.println(p);


        System.out.println("=====================================================");

        Field[] fiels2=personClass.getDeclaredFields();
        for (Field field2 : fiels2) {
            System.out.println("getDeclaredFields(): "+field2);
        }

        Field field3=personClass.getDeclaredField("name");
        System.out.println("getDeclaredField(): "+field3);
10. Class对象功能_获取Constructor
构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。
如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance
Class personClass=Person.class;
        Constructor constructor=personClass.getConstructor();
        Object p1=constructor.newInstance();
        System.out.println(p1);
        System.out.println("=========================================");


        Constructor constructor1=personClass.getConstructor(String.class,String.class);
        Object person1=constructor1.newInstance("aaa","bbb");
        System.out.println(person1);
        System.out.println("=========================================");

        Object person=personClass.newInstance();
        System.out.println(person);
11. class对象获取Method
使用method.getParameterTypes();可以获取该方法的参数
Class personClass=Person.class;
        Method[] methods=personClass.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
        System.out.println("=============================");

        Method method01=personClass.getMethod("eat");
        Person person=new Person();
        method01.invoke(person);
        System.out.println("==============================");
        Method method02=personClass.getMethod("eat",String.class);
        method02.invoke(person,"zhangsan")
12.反射
首先要从配置文件中读取该类的全限定类名，然后用class.forName()，来获取该类的class对象，再通过class对象获取并执行成员方法。
Properties properties=new Properties();
        ClassLoader cl=ClassTest05.class.getClassLoader();
        InputStream is=cl.getResourceAsStream("source.properties");
        properties.load(is);

        String className=properties.getProperty("className");
        String method=properties.getProperty("methodName");
        Class personClass=Class.forName(className);
        Object person=personClass.newInstance();
        Method method1=personClass.getMethod("eat");
        method1.invoke(person);
13* 作用分类：
		①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
		②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
		③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】
	
注解就是为了简化开发，避免写过多的代码，不利于程序的扩展以及维护        * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的
        * @Deprecated：该注解标注的内容，表示已过时
        * @SuppressWarnings：压制警告
            * 一般传递参数all  @SuppressWarnings("all")
14. 编写代码实现自定义注解
public @interface MyAnno {

     int value();
    Person per();
    MyAnno2 anno2();
    String[] strs();
     /*String name() default "张三";*/
     /*String show2();

     Person per();
     MyAnno2 anno2();

     String[] strs();*/


}
15. 元注解：用于描述注解的注解
            * @Target：描述注解能够作用的位置
                * ElementType取值：
                    * TYPE：可以作用于类上
                    * METHOD：可以作用于方法上
                    * FIELD：可以作用于成员变量上
            * @Retention：描述注解被保留的阶段
                * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
            * @Documented：描述注解是否被抽取到api文档中
            * @Inherited：描述注解是否被子类继承

day02__mysql基础
1.MySQL登录
            	1. mysql -uroot -p密码
          	 2. mysql -hip -uroot -p连接目标的密码
           	 3. mysql --host=ip --user=root --password=连接目标的密码
         MySQL退出
            	1. exit
            	2. quit
2.structured Query Language：结构化查询语言
其实就是定义了操作所有关系型数据库的规则
3.       . 3 种注释
            * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
            * 多行注释: /* 注释 */
4.SQL分类
1) DDL(Data Definition Language)数据定义语言
            用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
        2) DML(Data Manipulation Language)数据操作语言
            用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
        3) DQL(Data Query Language)数据查询语言
            用来查询数据库中表的记录(数据)。关键字：select, where 等
        4) DCL(Data Control Language)数据控制语言(了解)
            用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等


5.操作数据库：CRUD
		1. C(Create):创建
			* 创建数据库：
				* create database 数据库名称;
			* 创建数据库，判断不存在，再创建：
				* create database if not exists 数据库名称;
			* 创建数据库，并指定字符集
				* create database 数据库名称 character set 字符集名;

			* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
				* create database if not exists db4 character set gbk;
		2. R(Retrieve)：查询
			* 查询所有数据库的名称:
				* show databases;
			* 查询某个数据库的字符集:查询某个数据库的创建语句
				* show create database 数据库名称;
            3.U(Update):修改
			* 修改数据库的字符集
				* alter database 数据库名称 character set 字符集名称;
		4.D(Delete):删除
			* 删除数据库
				* drop database 数据库名称;
			* 判断数据库存在，存在再删除
				* drop database if exists 数据库名称;


6.使用数据库
			* 查询当前正在使用的数据库名称
				* select database();//不要忘记写()
			* 使用数据库
				* use 数据库名称;


7.查询某个数据库中所有的表名称
                * show tables;
            * 查询表结构(看表的键和值等)
                * desc 表名;

8.C(Create):创建
            1. 语法：
                create table 表名(
                    列名1 数据类型1,
                    列名2 数据类型2,
                    ....
                    列名n 数据类型n
                );
                * 注意：最后一列，不需要加逗号（,）

9.drop table 表名;
            * drop table  if exists 表名 ;

10.
1. 修改表名
				alter table 表名 rename to 新的表名;
			2. 修改表的字符集
				alter table 表名 character set 字符集名称;
			3. 添加一列
				alter table 表名 add 列名 数据类型;
			4. 修改列名称 类型
				alter table 表名 change 列名 新列别 新数据类型;
				alter table 表名 modify 列名 新数据类型;
			5. 删除列
				alter table 表名 drop 列名;
				
11.DML添加数据
* 语法：
            * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
        * 注意：
            1. 列名和值要一一对应。
            2. 如果表名后，不定义列名，则默认给所有列添加值
                insert into 表名 values(值1,值2,...值n);
            3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
12.DML删除数据
* 语法：
            * delete from 表名 [where 条件]
        * 注意：
            1. 如果不加条件，则删除表中所有记录。
            2. 如果要删除所有记录
                1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
                2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
13.DML修改数据
修改数据：
		* 语法：
			* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

		* 注意：
			1. 如果不加任何条件，则会将表中所有记录全部修改。


14.DQL基础查询

		1.多个字段的查询
			select 字段名1，字段名2... from 表名；
			* 注意：
			* 如果查询所有字段，则可以使用*来替代字段列表。
		2.去除重复：
			* distinct
		3.计算列
			* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
			* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
			* 表达式1：哪个字段需要判断是否为null
			* 如果该字段为null后的替换值。
		4.起别名：
			* as：as也可以省略

15.DQL条件查询
1. where子句后跟条件
		2. 运算符
			* > 、< 、<= 、>= 、= 、<>
			* BETWEEN...AND  
			* IN( 集合) 
			* LIKE：模糊查询
				* 占位符：
					* _:单个任意字符
					* %：多个任意字符
			* IS NULL  
			* and  或 &&
			* or  或 || 
			* not  或 !
16.DQL条件查询_模糊查询
LIKE：模糊查询
                * 占位符：
                    * _:单个任意字符
                    * %：多个任意字符
全国有多少人的名字中有“伟”的，就要用到like ‘%伟%’
17.DQL排序查询
语法：order by 子句
            * order by 排序字段1 排序方式1 ，排序字段2 排序方式2...
        * 排序方式：
            * ASC：升序，默认的。
            * DESC：降序
注意：
            * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件
18.DQL聚合函数
聚合函数对一组值执行计算并返回单一的值。除了 COUNT 以外，聚合函数忽略空值。聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。
聚合函数：将一列数据作为一个整体，进行纵向的计算。
        1. count：计算个数
            1. 一般选择非空的列：主键
 	    2. count(*)
        2. max：计算最大值
        3. min：计算最小值
        4. sum：计算和
        5. avg：计算平均值
19.DQL分组查询
	GROUP BY关键字可以将查询结果按照某个字段或多个字段进行分组。字段中值相等的为一组。基本的语法格式如下：
GROUP BY 属性名 [HAVING 条件表达式] [WITH ROLLUP]
   	• 属性名：是指按照该字段的值进行分组。
    	• HAVING 条件表达式：用来限制分组后的显示，符合条件表达式的结果将被显示。
    	• WITH ROLLUP：将会在所有记录的最后加上一条记录。加上的这一条记录是上面所有记录的总和。

	1. 语法：group by 分组字段；
        2. 注意：
            1. 分组之后查询的字段：分组字段、聚合函数
            2. where 和 having 的区别？
                1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
                2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。


ROUP BY关键字可以和GROUP_CONCAT()函数一起使用。GROUP_CONCAT()函数会把每个分组中指定的字段值都显示出来。

同时，GROUP BY关键字通常与集合函数一起使用。集合函数包括COUNT()函数、SUM()函数、AVG()函数、MAX()函数和MIN()函数等。

sql语句的执行过程是：from-->where-->group by -->having --- >order by --> select;
其执行顺序为：FROM-WHERE-GROUP BY-HAVING-SELECT-DISTINCT-UNION-ORDER BY
Mysql执行顺序：开始->FROM子句->WHERE子句->GROUP BY子句->HAVING子句->ORDER BY子句->SELECT子句->LIMIT子句->最终结果
聚合函数是针对结果集进行的，但是where条件并不是在查询出结果集之后运行，所以主函数放在where语句中，会出现错误，

而having不一样，having是针对结果集做筛选的，所以我门一般吧组函数放在having中，用having来代替where，having一般跟在group by后

20.约束概述 
对表中的数据进行限定，保证数据的正确性、有效性和完整性。
	主键约束（Primary Key constraint）：要求主键列数据唯一，并且不允许为空。
	唯一约束（Unique constraint）：要求该列唯一，允许为空，但只能出现一个空值。
	检查约束（Check constraint）：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。
	默认约束（Default constraint）：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。
	外键约束（Foreign Key constraint）：用于在两个表之间建立关系，需要指定引用主表的哪一列。

21.约束_非空约束
not null，某一列的值不能为null
	1. 创建表时添加约束
            CREATE TABLE stu(
                id INT,
                NAME VARCHAR(20) NOT NULL -- name为非空
            );
 	2. 创建表完后，添加非空约束
            ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;
 	3. 删除name的非空约束
            ALTER TABLE stu MODIFY NAME VARCHAR(20);

22. 约束_唯一约束
unique，某一列的值不能重复。注意：null值可以有多个。
唯一约束：unique，某一列的值不能重复
        1. 注意：
            * 唯一约束可以有NULL值
        2. 在创建表时，添加唯一约束
            CREATE TABLE stu(
                id INT,
                phone_number VARCHAR(20) UNIQUE -- 手机号
            );
        3. 删除唯一约束
            ALTER TABLE stu DROP INDEX phone_number;
        4. 在表创建完后，添加唯一约束
            ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
23.约束_主键约束
	primary key，非空并且唯一，一张表只能有一个主键，主键是表的唯一标识
	主键约束：primary key。
        1. 注意：
            1. 含义：非空且唯一
            2. 一张表只能有一个字段为主键
            3. 主键就是表中记录的唯一标识

        2. 在创建表时，添加主键约束
            create table stu(
                id int primary key,-- 给id添加主键约束
                name varchar(20)
            );

        3. 删除主键
            -- 错误 alter table stu modify id int ;
            ALTER TABLE stu DROP PRIMARY KEY;

        4. 创建完表后，添加主键
            ALTER TABLE stu MODIFY id INT PRIMARY KEY;



	主键主要用在查询单调数据，修改单调数据和删除单调数据上。
24.约束_主键约束_自动增长
	自动增长：
            1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完	成值得自动增长

            2. 在创建表时，添加主键约束，并且完成主键自增长
            create table stu(
                id int primary key auto_increment,-- 给id添加主键约束
                name varchar(20)
            );

            
            3. 删除自动增长
            ALTER TABLE stu MODIFY id INT;
            4. 添加自动增长
            ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;


	优点是：
		1.自动编号 速度快
		2.数字型 占用空间小 易排序
		3.不用担心主键重复的问题
	缺点是:
		1.在异库异构的数据库的情况下 容易新老主键混合 会发生冲突
		2.在系统集成的时候 如果主键的类型不一样的话 会导致其他外建关联的表的修改
		3.若系统也是数字型的，在导入时，为了区分新老数据，可能想在老数据主键前统一加一个字符标识（例如“o”，old）来表示这是老数据，那么自动增长的数字型又面临一个挑战。

25.约束_外键约束
foreign key,让表于表产生关系，从而保证数据的正确性。
外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。
        1. 在创建表时，可以添加外键
            * 语法：
                create table 表名(
                    ....
                    外键列
                    constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
                );

        2. 删除外键
            ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;

        3. 创建表之后，添加外键
            ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);

26.约束_外键约束_级联操作
	A表与B表有外键约束，A中有外键，B中数据改变时，A中的外键字段对应做出改变。
		1. 添加级联操作
                语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
                        FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;
           	2. 分类：
                1. 级联更新：ON UPDATE CASCADE 
                2. 级联删除：ON DELETE CASCADE 
27.多表关系介绍
		1.一对一(了解)：
                * 如：人和身份证
                * 分析：一个人只有一个身份证，一个身份证只能对应一个人
           	2. 一对多(多对一)：
                * 如：部门和员工
                * 分析：一个部门有多个员工，一个员工只能对应一个部门
            	3. 多对多：
		* 如：学生和课程
                * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
		 多对多：
                * 如：学生和课程
                * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键

		需要创建一张中间表来维护两张主表之间的关系，并且中间表最少要有两个字段。
		

28.
